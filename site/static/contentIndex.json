{"index":{"title":"Scheme Programming Language","links":["spec/R7RS-Small-Specification"],"tags":[],"content":"Scheme R7RS-Small Specification"},"spec/Formal-Syntax-and-Semantics":{"title":"Formal Syntax and Semantics","links":["spec/formal/Formal-Syntax","spec/formal/Formal-Semantics","spec/formal/Derived-Expression-Types"],"tags":[],"content":"\nFormal Syntax\nFormal Semantics\nDerived Expression Types\n"},"spec/Overview-of-Scheme":{"title":"Overview of Scheme","links":["spec/overview/Semantics","spec/overview/Syntax","spec/overview/Notation-and-Terminology"],"tags":[],"content":"\nSemantics\nSyntax\nNotation and Terminology\n"},"spec/R7RS-Small-Errata":{"title":"R7RS-Small Errata","links":["attachments/r7rs.pdf"],"tags":[],"content":"From github.com/johnwcowan/r7rs-work/blob/master/R7RSSmallErrata.md\nErrata from the final draft of R7RS.  This list is unofficial.\n\n\nIn Section 3.1 (Variables, syntactic keywords, and regions), the claim in paragraph 2 that all variable binding constructs can be explained in terms of lambda does not apply to top-level bindings.\n\n\nSection 7.1.5 (Transformers) doesn’t make it clear that a top-level syntax-rules pattern must be a list pattern, not a vector pattern or an identifier pattern.\n\n\nIn Section 6.3 (Booleans), the procedure boolean=? is defined to return #t if the arguments are all booleans and are either all #t or all #f.  The words “are all booleans and” incorrectly suggest that the value is #f if at least one argument is not a boolean.  In fact it is an error to apply boolean=? to non-booleans.\n\n\nIn Section 4.1.2 (Literal expressions), the examples &#039;# and # should be &#039;#\\a and #\\a respectively.\n\n\nIn section 7.1.1 (Lexical structure), the escape sequence \\| is not shown as permitted in string-element. The list in Section 6.7 shows that it is equivalent to |.  Similarly, the escape sequences \\&quot; and \\\\ should be allowed in symbol-element.  This makes the same escape sequences valid in both strings and symbols.\n\n\nIn Section 7.3 (Derived expression types), the syntax-rules definition of case is incorrect; the fourth syntax rule must be moved after the fifth to avoid an improper match against the fourth rule when =&gt; is present.  Here is the correct version:\n\n\n (define-syntax case\n   (syntax-rules (else =&gt;)\n     ((case (key ...)\n        clauses ...)\n      (let ((atom-key (key ...)))\n        (case atom-key clauses ...)))\n     ((case key\n        (else =&gt; result))\n      (result key))\n     ((case key\n        (else result1 result2 ...))\n      (begin result1 result2 ...))\n     ((case key\n        ((atoms ...) =&gt; result))\n      (if (memv key &#039;(atoms ...))\n          (result key)))\n     ((case key\n        ((atoms ...) =&gt; result)\n        clause clauses ...)\n      (if (memv key &#039;(atoms ...))\n          (result key)\n          (case key clause clauses ...)))\n     ((case key\n        ((atoms ...) result1 result2 ...))\n      (if (memv key &#039;(atoms ...))\n          (begin result1 result2 ...)))\n     ((case key\n        ((atoms ...) result1 result2 ...)\n        clause clauses ...)\n      (if (memv key &#039;(atoms ...))\n          (begin result1 result2 ...)\n          (case key clause clauses ...)))))\n\n\nIn Section 7.1.1, the lexical rule special-initial incorrectly omits @.\n\n\nBibliographic reference ![13] should link to SRFI 4.\n\n\nIn section 4.2.2, add “interleaving evaluations with assignments” to the definition of letrec*. Replace the meaningless example with this:\n\n\n;; Returns the arithmetic, geometric, and\n;; harmonic means of a nested list of numbers\n(define (means ton)\n  (letrec*\n     ((mean\n        (lambda (f g)\n          (f (/ (sum g ton) n))))\n      (sum\n        (lambda (g ton)\n          (if (null? ton)\n            (+)\n            (if (number? ton)\n                (g ton)\n                (+ (sum g (car ton))\n                   (sum g (cdr ton)))))))\n      (n (sum (lambda (x) 1) ton)))\n    (values (mean values values)\n            (mean exp log)\n            (mean / /))))\nNote that evaluating (means &#039;(3 (1 4))) returns three values: 8/3, 2.28942848510666 (approximately), and 36/19.\n\n\nIn section 7.1.5, add bytevector to the alternatives for the pattern-datum rule.\n\n\nSection 1.3.4 refers to “the initial environment” containing *, which is not true for programs. It should refer instead to “an environment containing the base library”.\n\n\nAn example in section 5.3.3 refers to integer-sqrt instead of exact-integer-sqrt.\n\n\nIn section 4.3.1, the body of a let-syntax expression is said to contain “one or more definitions”; it should be “zero or more definitions”.\n\n\nIn section 6.6 for char-upcase/downcase/foldcase and 6.7 for string-upcase/downcase/foldcase the reader is referred to UAX #29, but it should be TR #44.\n\n\nIn section 7.3, the definition of case-lambda should use letrec-syntax, not let-syntax.\n\n\nIn section 4.3.2 (but not in 7.1.3), change &lt;literal&gt; to &lt;pattern literal&gt; to avoid confusion.\n\n\n(removed, already in R7RS-small)\n\n\nIn the first bullet of the “Incompatibilities with R6RS” section, for “have to be be” read “have to be”.\n\n\nIn numeric tower bullet of the “Incompatibilities with R6RS” section, for “but the R6RS procedures real-valued?, rational-valued?, and integer-valued? were not” read “but the semantics of the R6RS procedures real?, rational?, and integer? were not adopted.  (Note that the R5RS/R7RS semantics are available in R6RS using real-valued?, rational-valued?, and integer-valued?)“.\n\n\nFrom Richard Kelsey’s R5RS errata: In the explanation of list-ref, for “fewer than k elements”, read “k or fewer elements”. Thus, (list-ref &#039;(x) 1) is an error.\n\n\nIn Appendix B, for “All algebraic operations except / produce exact values given exact inputs” read “The algebraic operations +, -, *, and expt where the second argument is a non-negative integer all produce exact values given exact inputs”.\n\n\nIn Appendix A, the (scheme r5rs) library should export syntax-rules, else, ..., =&gt; and _.\n\n\nIn the definition of string-for-each, for “the elements of the lists” read “the elements of the strings”.\n\n\nThe value of the example (real? 2.5+0.0i) in Section 6.2.6 is shown as #f, as in R6RS.  This contradicts the prose explanation.  No resolution of the conflict has been reached as yet.\n\n\nIn the definition of char-foldcase, the sentence “If the argument is an uppercase letter, the result will be either a lowercase letter or the same as the argument if the lowercase letter does not exist or is not supported by the implementation” is no longer appropriate as of Unicode 8.0, when folding began to convert Cherokee lower-case letters to upper case.  Replace it with “If the result of folding is not supported by the implementation, the argument is returned”.\n\n\nIn the definition of &lt;feature requirement&gt; in Section 7.1.7, for &lt;library name&gt; read (library &lt;library name&gt;).\n\n\nThe claim in the definition of current-second that the TAI-UTC offset as of January 1, 1970 was ten seconds is factually incorrect per the USNO’s list of offsets.  The correct value for that date is 8.000082 seconds.\n\n\nThe definition of char-numeric? refers to a nonexistent Unicode property Numeric_Digit. The intention was to refer to characters whose Numeric_Type property is Decimal, which is defined by Unicode as those which have a non-empty value in field 6 of the UnicodeData.txt file. This is equivalent to characters with a General Category of Nd. The simplest fix is to change the relevant paragraph of Section 6.6 from “Numeric_Digit” to “Numeric_Type=Decimal”.  (Note: R6RS uses the term “Numeric”, which also is not a Unicode property.)\n\n\nIn Section 6.5 (Symbols), the procedure symbol=? is defined to return #t if all the arguments are symbols and all have the same names in the sense of string=. The words “are all symbols and” incorrectly suggest that the value is #f if at least one argument is not a symbol.  In fact it is an error to apply symbol=? to non-symbols.  This is directly analogous to erratum 3.\n\n\nNotes that the categories Lu, Ll, … Co that are valid in identifiers apply only to non-ASCII characters; the valid ASCII characters are given explicitly.\n\n\nIn section 1.1, the sentence “Each use of a variable is associated with a lexically apparent binding of that variable” appears. However, this is only true after macroexpansion, as the binding may be hidden in a user-written macro.  Prefix the sentence with “After macros are expanded”.\n\n\nIn the third paragraph of the definition of null-environment, the reference to scheme-report-environment should be to null-environment, and is changed accordingly.\n\n\nIn Section 4.3.3 (Signaling errors in macro transformers) the example simple-let macro does not do what it appears to do: it will only trigger the syntax-error if the incorrect binding form is the last binding form in the list.\n\n"},"spec/R7RS-Small-Specification":{"title":"R7RS-Small Specification","links":["attachments/r7rs.pdf","spec/R7RS-Small-Errata","spec/Overview-of-Scheme","Lexical-Conventions","Basic-Concepts","spec/formal/syntax/Expressions","Program-Structure","Standard-Procedures","spec/Formal-Syntax-and-Semantics","Standard-Libraries","Standard-Feature-Identifiers"],"tags":[],"content":"This is the R7RS-Small specification, broken out and reformatted from the original PDF version.\nNote that the R7RS-Small Errata have not yet been fully incorporated.\n\nProgramming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary\n\nContents:\n\nOverview of Scheme\nLexical Conventions\nBasic Concepts\nExpressions\nProgram Structure\nStandard Procedures\nFormal Syntax and Semantics\n\n\nAppendices:\n\nStandard Libraries\nStandard Feature Identifiers\n"},"spec/concepts/Proper-Tail-Recursion":{"title":"Proper Tail Recursion","links":[],"tags":[],"content":""},"spec/formal/Derived-Expression-Types":{"title":"Derived Expression Types","links":[],"tags":[],"content":""},"spec/formal/Formal-Semantics":{"title":"Formal Semantics","links":["tags/todo"],"tags":["todo"],"content":"todo"},"spec/formal/Formal-Syntax":{"title":"Formal Syntax","links":["tags/todo"],"tags":["todo"],"content":"todo"},"spec/formal/syntax/Expressions":{"title":"Expressions","links":[],"tags":[],"content":""},"spec/formal/syntax/External-Representations":{"title":"External Representations","links":[],"tags":[],"content":""},"spec/formal/syntax/Lexical-Structure":{"title":"Lexical Structure","links":[],"tags":[],"content":""},"spec/formal/syntax/Libraries":{"title":"Libraries","links":[],"tags":[],"content":""},"spec/formal/syntax/Programs-and-Definitions":{"title":"Programs and Definitions","links":[],"tags":[],"content":""},"spec/formal/syntax/Quasiquotations":{"title":"Quasiquotations","links":[],"tags":[],"content":""},"spec/formal/syntax/Transformers":{"title":"Transformers","links":[],"tags":[],"content":""},"spec/overview/Notation-and-Terminology":{"title":"Notation and Terminology","links":[],"tags":[],"content":""},"spec/overview/Semantics":{"title":"Semantics","links":["spec/formal/Formal-Semantics","spec/concepts/Proper-Tail-Recursion","spec/procedures/Control-Features"],"tags":[],"content":"See also Formal Semantics.\nScoping\nScheme is a statically scoped programming language. After macros are expanded, each use of a variable is associated with a lexically apparent binding of that variable.\nTyping\nScheme is a dynamically typed language. Types are associated with values (also called objects) rather than with variables. Statically typed languages, by contrast, associate types with variables and expressions as well as with values.\nMemory Management\nAll objects created in the course of a Scheme computation, including procedures and continuations, have unlimited extent. No Scheme object is ever destroyed. The reason that implementations of Scheme do not (usually!) run out of storage is that they are permitted to reclaim the storage occupied by an object if they can prove that the object cannot possibly matter to any future computation.\nTail-Calls\nImplementations of Scheme are required to be properly tail-recursive. This allows the execution of an iterative computation in constant space, even if the iterative computation is described by a syntactically recursive procedure. Thus with a properly tail-recursive implementation, iteration can be expressed using the ordinary procedure-call mechanics, so that special iteration constructs are useful only as syntactic sugar. See Proper Tail Recursion.\nFirst-Class Procedures and Continuations\nScheme procedures are objects in their own right. Procedures can be created dynamically, stored in data structures, returned as results of procedures, and so on.\nOne distinguishing feature of Scheme is that continuations, which in most other languages only operate behind the scenes, also have “first-class” status. Continuations are useful for implementing a wide variety of advanced control constructs, including non-local exits, backtracking, and coroutines. See Control Features.\nEager Arguments\nArguments to Scheme procedures are always passed by value, which means that the actual argument expressions are evaluated before the procedure gains control, regardless of whether the procedure needs the result of the evaluation.\nNumeric Tower\nScheme’s model of arithmetic is designed to remain as independent as possible of the particular ways in which numbers are represented within a computer. In Scheme, every integer is a rational number, every rational is a real, and every real is a complex number. Thus the distinction between integer and real arithmetic, so important to many programming languages, does not appear in Scheme. In its place is a distinction between exact arithmetic, which corresponds to the mathematical ideal, and inexact arithmetic on approximations. Exact arithmetic is not limited to integers."},"spec/overview/Syntax":{"title":"Syntax","links":["spec/formal/Formal-Syntax","spec/procedures/io/input/Read","spec/formal/syntax/External-Representations"],"tags":[],"content":"See also Formal Syntax.\nScheme, like most dialects of Lisp, employs a fully parenthesized prefix notation for programs and other data; the grammar of Scheme generates a sublanguage of the language used for data. An important consequence of this simple, uniform representation is that Scheme programs and data can easily be treated uniformly by other Scheme programs. For example, the eval procedure evaluates a Scheme program expressed as data.\nThe read procedure performs syntactic as well as lexical decomposition of the data it reads. The read procedure parses its input as data (see External Representations), not as program."},"spec/procedures/Control-Features":{"title":"Control Features","links":[],"tags":[],"content":""},"spec/procedures/io/input/Read":{"title":"Read","links":["tags/procedure"],"tags":["procedure"],"content":"procedure"},"tags/procedure":{"title":"procedure","links":[],"tags":[],"content":"Scheme standard procedure definitions."},"tags/todo":{"title":"todo","links":[],"tags":[],"content":"Use this tag to mark action items in pages."}}